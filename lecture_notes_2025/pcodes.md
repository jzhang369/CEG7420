# **Programming with P-Codes in Ghidra**

## **Why Care about P-Codes?**

Pcode is Ghidra’s intermediate representation (IR) used to abstract (a.k.a "lift") assembly instructions across different CPU architectures. It simplifies analysis and enables automated reverse engineering by explicitly representing instruction semantics.

P-code offers a few unique advantages for reverse engineering and program analysis:
+ **Architecture Abstraction**: Provides a uniform representation across different CPU architectures.
+ **Explicit Side-Effects**: Clearly represents side-effects of assembly instructions that may not be immediately apparent.
+ **Built-In Data Flow**: Used for data-flow tracking, taint analysis, and symbolic execution. (Only supported by Refined pcodes though.)

The following table illustrates how these features facilitate two critical program analysis strategies. 

|Feature|Emulation|Static Analysis|
|:---:|:----:|:-----:|
|Architecture Abstraction|X|X|
|Explicit Side-Effects|X||
|Built-In Data Flow||X|

## Raw and Refined P-Codes ##

Ghidra defines two types of p-codes that share the same syntax but differ fundamentally in semantics. Although Ghidra itself does not assign specific names to these types, many articles and discussions refer to them as *raw* or *low* p-codes and *refined* or *high* p-codes, respectively.

+ **Raw P-code (Low P-code)**
  + **Generated by:** The SLEIGH language translator from processor specification files (`.sla`).
  - **Level:** Low-level, closely mirrors the original machine instructions.
  - **Purpose:** Serves as a detailed, accurate breakdown of the instruction’s hardware-level effects.
  - **Characteristics:**
    - Direct translation from binary opcodes.
    - Represents micro-operations (e.g., shifts, masking, flag updates).
    - Contains temporary registers and precise bit-level manipulations.
    - Not optimized for readability or high-level logic.

+ **Refined P-code (High P-code)**
  + **Generated by:** Ghidra’s decompiler after semantic lifting, type recovery, and optimization.
  + **Level:** Higher-level abstraction that aligns with source code constructs.
  + **Purpose:** Aims to reconstruct the program's intent and simplify control and data flow.
  + **Characteristics:**
    - Abstracts low-level hardware details.
    - Introduces cleaner expressions and temporary variables.
    - In Static Single Assignment (SSA) form
    - Aids in reconstructing functions, loops, and conditionals.

```mermaid
graph BT
    subgraph ASM[Hardware-Specific ASM]
        A1[x86]
        A2[ARM]
        A3[MIPS]
        A4[PowerPC]
    end

    B[SLEIGH Language Translator]
    C[Raw P-code]
    D[Decompiler Engine]
    E[Refined P-code]
    F[Decompiled C/C++ Code]

    A1 --> B
    A2 --> B
    A3 --> B
    A4 --> B
    B --> C
    C --> D
    D --> E
    E --> F
```


**Summary Table - Comparison Between Raw and Refined P-codes**

| Feature              | Raw P-code                  | Refined P-code              |
|----------------------|-----------------------------|-----------------------------|
|**Syntax**| P-Code| P-Code|
| **Generated by**     | SLEIGH                      | Decompiler engine           |
| **Level**            | Low-level (CPU behavior)    | High-level (source logic)   |
| **Use case**         | Emulation, lifting | Decompilation, analysis  |
| **Hardware-specific?** | No                       | No                          |
| **Human readability**| Low                         | High                        |
| **In SSA form?**     | No                   | Yes                      |





## **Where to Find More Information?**

/docs/GhidraAPI_javadoc/api/ghidra/program/model/pcode/PcodeOp.html

/docs/GhidraAPI_javadoc/api/ghidra/program/model/pcode/PcodeOpAST.html

/docs/languages/index.html


## **P-Code Syntax**

A p-code operation is the analog of a machine instruction. 
+ A Machine Instruction
  + **opcode**: the action taken by this instruction (e.g., `ADD`, `JMP`, and etc.). 
  + **oprand**: the input(s) and output of this instruction (e.g., a register, a memory address, and etc.)
  + **Side Effects**: a machine instruction may have side effects (e.g., by implicitly changing flag registers.)
+ A p-code operation
  + **opcode**: the action taken by this p-code operation
  + **varnode**: the input(s) and output of this p-code operation. 
  + **Side Effects**: for almost all p-code operations, only the output varnode can have its value modified; there are no indirect effects of the operation. 



## **Mapping Between Assembly Instructions and P-Code Operations**

### **From Assembly to P-Code**

### **From P-Code to Assembly**
Every p-code operation is associated with the original machine/assembly instruction where it originates from. It should be made clear that one machine instruction is typically translated into one p-code operation or a sequence of p-code instructions. Each p-code operation is uniquely identified by its **sequence number**. 
1. Each p-code operation is associated with **the address** of the original processor instruction it originates from.  
1. For a single instruction, a **1-up counter**, starting at zero, is used to enumerate the multiple p-code operations involved in its translation. 

The address and counter as a pair are referred to as the p-code op's unique **sequence number**. 

Similar to machine/assembly instructions, control-flow of p-code operations generally follows sequence number order. 
+ When execution of all p-code for one instruction is completed, if the instruction has fall-through semantics, p-code control-flow picks up with the first p-code operation in sequence corresponding to the instruction at the fall-through address. Similarly, if a p-code operation results in a control-flow branch, the first p-code operation in sequence executes at the destination address.




## **Working with PCodess**






### Refined P-Codes

Only refined p-codes are represented in **Static Single Assignment (SSA)** form, a key property that:

- Ensures **every variable is assigned exactly once**.
- Introduces new unique versions (e.g., `tmp1`, `tmp2`, etc.) for each assignment.
- Makes **data flow analysis**, **value tracking**, and **optimization** easier.

SSA enables:

- Precise dependency tracking for each variable use.
- Simplified reasoning about program state at any point.
- Better support for symbolic execution and taint analysis.


SSA Examples (Yes/No?):

```python
# Yes or No?
x = 5
x = x + 2
x = x * 3
```

```python
# Yes or No?
x1 = 5
x2 = x1 + 2
x3 = x2 * 3
```

```python
# Yes or No?
if (cond):
    x = 1
else:
    x = 2
    y = x + 3
```


```python
# Yes or No?
if (cond):
    x1 = 1
else:
    x2 = 2
    x3 = phi(x1, x2)
    y1 = x3 + 3
```



### **How to Enumerate all Basic Blocks in a Binary Using Ghidra?**
