# **Programming with P-Codes in Ghidra**

## **Why Care about P-Codes?**

Pcode is Ghidra’s intermediate representation (IR) used to abstract (a.k.a "lift") assembly instructions across different CPU architectures. It simplifies analysis and enables automated reverse engineering by explicitly representing instruction semantics.

P-code offers a few unique advantages for reverse engineering and program analysis:
+ **Architecture Abstraction**: Provides a uniform representation across different CPU architectures.
+ **Explicit Side-Effects**: Clearly represents side-effects of assembly instructions that may not be immediately apparent.
+ **Built-In Data Flow**: Used for data-flow tracking, taint analysis, and symbolic execution. (Only supported by Refined pcodes though.)

The following table illustrates how these features facilitate two critical program analysis strategies. 

|Feature|Emulation|Static Analysis|
|:---:|:----:|:-----:|
|Architecture Abstraction|X|X|
|Explicit Side-Effects|X||
|Built-In Data Flow||X|

## Raw and Refined P-Codes ##

Ghidra defines two types of p-codes that share the same syntax but differ fundamentally in semantics. Although Ghidra itself does not assign specific names to these types, many articles and discussions refer to them as *raw* or *low* p-codes and *refined* or *high* p-codes, respectively.

+ **Raw P-code (Low P-code)**
  + **Generated by:** The SLEIGH language translator from processor specification files (`.sla`).
  - **Level:** Low-level, closely mirrors the original machine instructions.
  - **Purpose:** Serves as a detailed, accurate breakdown of the instruction’s hardware-level effects.
  - **Characteristics:**
    - Direct translation from binary opcodes.
    - Represents micro-operations (e.g., shifts, masking, flag updates).
    - Contains temporary registers and precise bit-level manipulations.
    - Not optimized for readability or high-level logic.

+ **Refined P-code (High P-code)**
  + **Generated by:** Ghidra’s decompiler after semantic lifting, type recovery, and optimization.
  + **Level:** Higher-level abstraction that aligns with source code constructs.
  + **Purpose:** Aims to reconstruct the program's intent and simplify control and data flow.
  + **Characteristics:**
    - Abstracts low-level hardware details.
    - Introduces cleaner expressions and temporary variables.
    - In Static Single Assignment (SSA) form
    - Aids in reconstructing functions, loops, and conditionals.





**Summary Table - Comparison Between Raw and Refined P-codes**

| Feature              | Raw P-code                  | Refined P-code              |
|----------------------|-----------------------------|-----------------------------|
|**Syntax**| P-Code| P-Code|
| **Generated by**     | SLEIGH                      | Decompiler engine           |
| **Level**            | Low-level (CPU behavior)    | High-level (source logic)   |
| **Use case**         | Emulation, lifting | Decompilation, analysis  |
| **Hardware-specific?** | No                       | No                          |
| **Human readability**| Low                         | High                        |
| **In SSA form?**     | No                   | Yes                      |





## **Where to Find More Information?**

/docs/GhidraAPI_javadoc/api/ghidra/program/model/pcode/PcodeOp.html

/docs/GhidraAPI_javadoc/api/ghidra/program/model/pcode/PcodeOpAST.html

/docs/languages/index.html


## **P-Code Syntax**


## **Working with PCodess**






### Refined P-Codes

Only refined p-codes are represented in **Static Single Assignment (SSA)** form, a key property that:

- Ensures **every variable is assigned exactly once**.
- Introduces new unique versions (e.g., `tmp1`, `tmp2`, etc.) for each assignment.
- Makes **data flow analysis**, **value tracking**, and **optimization** easier.

SSA enables:

- Precise dependency tracking for each variable use.
- Simplified reasoning about program state at any point.
- Better support for symbolic execution and taint analysis.


SSA Examples (Yes/No?):

```python
# Yes or No?
x = 5
x = x + 2
x = x * 3
```

```python
# Yes or No?
x1 = 5
x2 = x1 + 2
x3 = x2 * 3
```

```python
# Yes or No?
if (cond):
    x = 1
else:
    x = 2
    y = x + 3
```


```python
# Yes or No?
if (cond):
    x1 = 1
else:
    x2 = 2
    x3 = phi(x1, x2)
    y1 = x3 + 3
```



### **How to Enumerate all Basic Blocks in a Binary Using Ghidra?**
